# åŸºäºRHIé£æ ¼çš„å›¾å½¢ç®¡çº¿çŠ¶æ€å¯¹è±¡ (GraphicsPipeline) å®ç°è®¡åˆ’

## æ€»ä½“è®¾è®¡ç†å¿µ

åŸºäºç°æœ‰RHIå±‚çš„è®¾è®¡é£æ ¼ï¼ŒGraphicsPipelineç³»ç»Ÿå°†é‡‡ç”¨æ¥å£æŠ½è±¡ã€ç±»å‹åˆ†ç¦»ã€å¹³å°å®ç°åˆ†ç¦»çš„è®¾è®¡æ¨¡å¼ã€‚è¯¥ç³»ç»Ÿå°è£…ä¸åŒå›¾å½¢APIä¸­çš„ç®¡çº¿çŠ¶æ€å¯¹è±¡æ¦‚å¿µï¼ˆå¦‚D3D12çš„PSOã€OpenGLçš„çŠ¶æ€ç»„åˆï¼‰ï¼ŒåŒæ—¶è€ƒè™‘åˆ°OpenGLè¿è¡Œæ—¶çŠ¶æ€è®¾ç½®çš„ç‰¹æ€§ã€‚

## æ–‡ä»¶ç»“æ„å’Œç±»ç»„ç»‡

```
ğŸ“ Hazel/src/Hazel/RHI/Interface/
â”œâ”€â”€ ğŸ“„ PipelineTypes.h              # ç®¡çº¿ç›¸å…³ç±»å‹å®šä¹‰
â”œâ”€â”€ ğŸ“„ IPipelineStateManager.h      # ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨æ¥å£
â””â”€â”€ ğŸ“„ IGraphicsPipeline.h          # å›¾å½¢ç®¡çº¿æ¥å£

ğŸ“ Platform/D3D12/
â”œâ”€â”€ ğŸ“„ D3D12PipelineStateManager.h  # D3D12ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨
â”œâ”€â”€ ğŸ“„ D3D12PipelineStateManager.cpp
â”œâ”€â”€ ğŸ“„ D3D12GraphicsPipeline.h      # D3D12å›¾å½¢ç®¡çº¿å®ç°
â””â”€â”€ ğŸ“„ D3D12GraphicsPipeline.cpp

ğŸ“ Platform/OpenGL/ (æœªæ¥å®ç°)
â”œâ”€â”€ ğŸ“„ OpenGLPipelineStateManager.h
â”œâ”€â”€ ğŸ“„ OpenGLPipelineStateManager.cpp
â”œâ”€â”€ ğŸ“„ OpenGLGraphicsPipeline.h
â””â”€â”€ ğŸ“„ OpenGLGraphicsPipeline.cpp
```

## è¯¦ç»†ç±»è®¾è®¡

### 1. ç±»å‹å®šä¹‰ - PipelineTypes.h

```cpp
#pragma once

namespace Hazel {

    // åŸºç¡€æ¸²æŸ“çŠ¶æ€æšä¸¾
    enum class BlendFactor {
        Zero, One, SrcColor, InvSrcColor, SrcAlpha, InvSrcAlpha,
        DstColor, InvDstColor, DstAlpha, InvDstAlpha, ConstantColor, InvConstantColor
    };

    enum class BlendOp {
        Add, Subtract, ReverseSubtract, Min, Max
    };

    enum class DepthFunc {
        Never, Less, LessEqual, Equal, NotEqual, GreaterEqual, Greater, Always
    };

    enum class CullMode {
        None, Front, Back
    };

    enum class FillMode {
        Solid, Wireframe, Point
    };

    enum class PrimitiveTopology {
        PointList, LineList, LineStrip, TriangleList, TriangleStrip
    };

    // ç®¡çº¿çŠ¶æ€æè¿°ç»“æ„ä½“
    struct RasterizerStateDesc {
        FillMode fillMode = FillMode::Solid;
        CullMode cullMode = CullMode::Back;
        bool frontCounterClockwise = false;
        bool depthClipEnable = true;
        bool scissorEnable = false;
        float depthBias = 0.0f;
        float depthBiasClamp = 0.0f;
        float slopeScaledDepthBias = 0.0f;
        
        // ä¾¿æ·é™æ€æ–¹æ³•
        static RasterizerStateDesc Default() {
            return RasterizerStateDesc{};
        }
        
        static RasterizerStateDesc NoCull() {
            RasterizerStateDesc desc;
            desc.cullMode = CullMode::None;
            return desc;
        }
        
        static RasterizerStateDesc Wireframe() {
            RasterizerStateDesc desc;
            desc.fillMode = FillMode::Wireframe;
            return desc;
        }
    };

    struct BlendStateDesc {
        struct RenderTargetBlend {
            bool blendEnable = false;
            BlendFactor srcColorBlendFactor = BlendFactor::One;
            BlendFactor dstColorBlendFactor = BlendFactor::Zero;
            BlendOp colorBlendOp = BlendOp::Add;
            BlendFactor srcAlphaBlendFactor = BlendFactor::One;
            BlendFactor dstAlphaBlendFactor = BlendFactor::Zero;
            BlendOp alphaBlendOp = BlendOp::Add;
            uint8_t colorWriteMask = 0xF; // RGBA
        };

        bool alphaToCoverageEnable = false;
        bool independentBlendEnable = false;
        RenderTargetBlend renderTargetBlend[8];
        
        // ä¾¿æ·é™æ€æ–¹æ³•
        static BlendStateDesc Opaque() {
            return BlendStateDesc{};
        }
        
        static BlendStateDesc AlphaBlend() {
            BlendStateDesc desc;
            desc.renderTargetBlend[0].blendEnable = true;
            desc.renderTargetBlend[0].srcColorBlendFactor = BlendFactor::SrcAlpha;
            desc.renderTargetBlend[0].dstColorBlendFactor = BlendFactor::InvSrcAlpha;
            return desc;
        }
        
        static BlendStateDesc Additive() {
            BlendStateDesc desc;
            desc.renderTargetBlend[0].blendEnable = true;
            desc.renderTargetBlend[0].srcColorBlendFactor = BlendFactor::One;
            desc.renderTargetBlend[0].dstColorBlendFactor = BlendFactor::One;
            return desc;
        }
    };

    struct DepthStencilStateDesc {
        bool depthEnable = true;
        bool depthWriteEnable = true;
        DepthFunc depthFunc = DepthFunc::Less;
        bool stencilEnable = false;
        uint8_t stencilReadMask = 0xFF;
        uint8_t stencilWriteMask = 0xFF;
        
        // ä¾¿æ·é™æ€æ–¹æ³•
        static DepthStencilStateDesc Default() {
            return DepthStencilStateDesc{};
        }
        
        static DepthStencilStateDesc ReadOnly() {
            DepthStencilStateDesc desc;
            desc.depthWriteEnable = false;
            return desc;
        }
        
        static DepthStencilStateDesc Disabled() {
            DepthStencilStateDesc desc;
            desc.depthEnable = false;
            desc.depthWriteEnable = false;
            return desc;
        }
    };

    // å›¾å½¢ç®¡çº¿æè¿°ç»“æ„ï¼ˆä¸“æ³¨äºæ¸²æŸ“çŠ¶æ€ï¼‰
    struct GraphicsPipelineDesc {
        Ref<Shader> shader;                    // Shaderç¨‹åº
        RasterizerStateDesc rasterizerState;   // å…‰æ …åŒ–çŠ¶æ€
        BlendStateDesc blendState;             // æ··åˆçŠ¶æ€
        DepthStencilStateDesc depthStencilState; // æ·±åº¦æ¨¡æ¿çŠ¶æ€
        PrimitiveTopology primitiveTopology = PrimitiveTopology::TriangleList;
        
        // æ¸²æŸ“ç›®æ ‡æ ¼å¼
        enum class TextureFormat {
            RGBA8, BGRA8, RGBA16F, RGBA32F, DEPTH24STENCIL8, DEPTH32F
        } colorFormat = TextureFormat::RGBA8;
        TextureFormat depthStencilFormat = TextureFormat::DEPTH24STENCIL8;
        
        uint32_t sampleCount = 1;
        uint32_t sampleQuality = 0;
        
        // ä¾¿æ·é“¾å¼è®¾ç½®æ–¹æ³•
        GraphicsPipelineDesc& SetShader(const Ref<Shader>& shader_) {
            shader = shader_;
            return *this;
        }
        
        // æ³¨æ„ï¼šVertexLayout ä» Pipeline ä¸­ç§»é™¤ï¼Œåº”ç‹¬ç«‹ç®¡ç†
        
        GraphicsPipelineDesc& SetRasterizerState(const RasterizerStateDesc& state) {
            rasterizerState = state;
            return *this;
        }
        
        GraphicsPipelineDesc& SetBlendState(const BlendStateDesc& state) {
            blendState = state;
            return *this;
        }
        
        GraphicsPipelineDesc& SetDepthStencilState(const DepthStencilStateDesc& state) {
            depthStencilState = state;
            return *this;
        }
        
        GraphicsPipelineDesc& SetPrimitiveTopology(PrimitiveTopology topology) {
            primitiveTopology = topology;
            return *this;
        }
    };

    // ç®¡çº¿çŠ¶æ€å¥æŸ„ (ç±»ä¼¼DescriptorHandleçš„è®¾è®¡)
    struct PipelineStateHandle {
        uint64_t id = 0;
        bool isValid = false;
        
        bool IsValid() const { return isValid; }
    };

} // namespace Hazel
```

### 2. å›¾å½¢ç®¡çº¿æ¥å£ - IGraphicsPipeline.h

```cpp
#pragma once

#include "PipelineTypes.h"
#include "Hazel/Core/Base.h"

namespace Hazel {

    class IGraphicsPipeline {
    public:
        virtual ~IGraphicsPipeline() = default;
        
        // ç»‘å®šç®¡çº¿çŠ¶æ€ï¼ˆè€ƒè™‘OpenGLéœ€è¦è¿è¡Œæ—¶è®¾ç½®çŠ¶æ€ï¼‰
        virtual void Bind() const = 0;
        
        // è·å–ç®¡çº¿æè¿°
        virtual const GraphicsPipelineDesc& GetDescription() const = 0;
        
        // è·å–ç®¡çº¿çŠ¶æ€å¥æŸ„
        virtual PipelineStateHandle GetHandle() const = 0;
        
        // å¹³å°ç‰¹å®šçš„åŸç”Ÿå¯¹è±¡è®¿é—®ï¼ˆå¯é€‰ï¼‰
        virtual void* GetNativeHandle() const { return nullptr; }
        
        // éªŒè¯ç®¡çº¿çŠ¶æ€æ˜¯å¦æœ‰æ•ˆ
        virtual bool IsValid() const = 0;
    };

} // namespace Hazel
```

### 3. ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨æ¥å£ - IPipelineStateManager.h

```cpp
#pragma once

#include "IGraphicsPipeline.h"
#include "PipelineTypes.h"
#include <unordered_map>

namespace Hazel {

    class IPipelineStateManager {
    public:
        virtual ~IPipelineStateManager() = default;
        
        // åˆ›å»ºå›¾å½¢ç®¡çº¿
        virtual Ref<IGraphicsPipeline> CreateGraphicsPipeline(const GraphicsPipelineDesc& desc) = 0;
        
        // ç®¡çº¿ç¼“å­˜å’Œå¤ç”¨
        virtual Ref<IGraphicsPipeline> GetOrCreatePipeline(const GraphicsPipelineDesc& desc) = 0;
        
        // æ¸…ç†æ— ç”¨çš„ç®¡çº¿
        virtual void GarbageCollect() = 0;
        
        // è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
        virtual size_t GetCachedPipelineCount() const = 0;
        
        // å•ä¾‹è®¿é—®ï¼ˆç±»ä¼¼IGfxViewManager::Get()çš„é£æ ¼ï¼‰
        static IPipelineStateManager& Get();
        
    protected:
        // ç®¡çº¿å“ˆå¸Œå’Œç¼“å­˜
        virtual uint64_t HashPipelineDesc(const GraphicsPipelineDesc& desc) const = 0;
        std::unordered_map<uint64_t, Ref<IGraphicsPipeline>> m_PipelineCache;
    };

} // namespace Hazel
```

### 4. D3D12å®ç° - D3D12GraphicsPipeline.h

```cpp
#pragma once

#include "Hazel/RHI/Interface/IGraphicsPipeline.h"
#include <d3d12.h>
#include <wrl/client.h>

namespace Hazel {

    class D3D12GraphicsPipeline : public IGraphicsPipeline {
    public:
        D3D12GraphicsPipeline(const GraphicsPipelineDesc& desc);
        virtual ~D3D12GraphicsPipeline();
        
        // IGraphicsPipeline å®ç°
        virtual void Bind() const override;
        virtual const GraphicsPipelineDesc& GetDescription() const override { return m_Description; }
        virtual PipelineStateHandle GetHandle() const override;
        virtual void* GetNativeHandle() const override { return m_PipelineState.Get(); }
        virtual bool IsValid() const override;
        
        // D3D12ç‰¹å®šæ¥å£
        ID3D12PipelineState* GetD3D12PipelineState() const { return m_PipelineState.Get(); }
        ID3D12RootSignature* GetD3D12RootSignature() const { return m_RootSignature.Get(); }
        
    private:
        void CreateRootSignature();
        void CreatePipelineState();
        
        // çŠ¶æ€è½¬æ¢å‡½æ•°
        D3D12_RASTERIZER_DESC ConvertRasterizerState(const RasterizerStateDesc& desc) const;
        D3D12_BLEND_DESC ConvertBlendState(const BlendStateDesc& desc) const;
        D3D12_DEPTH_STENCIL_DESC ConvertDepthStencilState(const DepthStencilStateDesc& desc) const;
        
        GraphicsPipelineDesc m_Description;
        Microsoft::WRL::ComPtr<ID3D12PipelineState> m_PipelineState;
        Microsoft::WRL::ComPtr<ID3D12RootSignature> m_RootSignature;
        PipelineStateHandle m_Handle;
    };

} // namespace Hazel
```

### 5. D3D12ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨ - D3D12PipelineStateManager.h

```cpp
#pragma once

#include "Hazel/RHI/Interface/IPipelineStateManager.h"
#include "D3D12GraphicsPipeline.h"

namespace Hazel {

    class D3D12PipelineStateManager : public IPipelineStateManager {
    public:
        D3D12PipelineStateManager();
        virtual ~D3D12PipelineStateManager();
        
        // IPipelineStateManager å®ç°
        virtual Ref<IGraphicsPipeline> CreateGraphicsPipeline(const GraphicsPipelineDesc& desc) override;
        virtual Ref<IGraphicsPipeline> GetOrCreatePipeline(const GraphicsPipelineDesc& desc) override;
        virtual void GarbageCollect() override;
        virtual size_t GetCachedPipelineCount() const override;
        
    protected:
        virtual uint64_t HashPipelineDesc(const GraphicsPipelineDesc& desc) const override;
        
    private:
        static std::unique_ptr<D3D12PipelineStateManager> s_Instance;
        friend class IPipelineStateManager;
    };

} // namespace Hazel
```

### 6. OpenGLå®ç°è®¾è®¡è€ƒè™‘ (æœªæ¥å®ç°)

#### OpenGLGraphicsPipeline.h

```cpp
#pragma once

#include "Hazel/RHI/Interface/IGraphicsPipeline.h"

namespace Hazel {

    // OpenGLå®ç°ï¼šè¿è¡Œæ—¶çŠ¶æ€è®¾ç½®æ¨¡å¼
    class OpenGLGraphicsPipeline : public IGraphicsPipeline {
    public:
        OpenGLGraphicsPipeline(const GraphicsPipelineDesc& desc);
        virtual ~OpenGLGraphicsPipeline();
        
        // IGraphicsPipeline å®ç°
        virtual void Bind() const override;
        virtual const GraphicsPipelineDesc& GetDescription() const override { return m_Description; }
        virtual PipelineStateHandle GetHandle() const override;
        virtual void* GetNativeHandle() const override { return reinterpret_cast<void*>(m_ProgramID); }
        virtual bool IsValid() const override;
        
    private:
        void CompileShaderProgram();
        void CacheRenderStates();
        
        // OpenGLç‰¹å®šï¼šè¿è¡Œæ—¶çŠ¶æ€è®¾ç½®å‡½æ•°
        void ApplyRasterizerState() const;
        void ApplyBlendState() const;
        void ApplyDepthStencilState() const;
        
        GraphicsPipelineDesc m_Description;
        uint32_t m_ProgramID = 0;
        uint32_t m_VertexArrayObject = 0; // å¯èƒ½éœ€è¦VAO
        PipelineStateHandle m_Handle;
        
        // ç¼“å­˜çš„OpenGLçŠ¶æ€ä¿¡æ¯
        mutable bool m_StatesDirty = true;
    };

} // namespace Hazel
```

## éœ€è¦åˆ›å»ºçš„ç±»æ¸…å•

### ğŸ”§ æ¥å£ç±» (RHI/Interface)
1. **IGraphicsPipeline** - å›¾å½¢ç®¡çº¿æ¥å£
2. **IPipelineStateManager** - ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨æ¥å£

### ğŸ“Š ç±»å‹ç±» (RHI/Interface) 
3. **PipelineTypes.h** - æ‰€æœ‰ç®¡çº¿ç›¸å…³çš„æšä¸¾ã€ç»“æ„ä½“å’Œæè¿°ç¬¦

### ğŸ® D3D12å¹³å°å®ç° (Platform/D3D12)
4. **D3D12GraphicsPipeline** - D3D12å›¾å½¢ç®¡çº¿å®ç°ï¼ˆé¢„ç¼–è¯‘PSOæ¨¡å¼ï¼‰
5. **D3D12PipelineStateManager** - D3D12ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨

### ğŸ”® OpenGLå¹³å°å®ç° (Platform/OpenGL) - æœªæ¥å®ç°
6. **OpenGLGraphicsPipeline** - OpenGLå›¾å½¢ç®¡çº¿å®ç°ï¼ˆè¿è¡Œæ—¶çŠ¶æ€è®¾ç½®æ¨¡å¼ï¼‰
7. **OpenGLPipelineStateManager** - OpenGLç®¡çº¿çŠ¶æ€ç®¡ç†å™¨

## ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€ä½¿ç”¨
```cpp
// åˆ›å»ºç®¡çº¿æè¿°ï¼ˆåªåŒ…å«æ¸²æŸ“çŠ¶æ€ï¼‰
auto pipelineDesc = GraphicsPipelineDesc{}
    .SetShader(m_ColorShader)
    .SetRasterizerState(RasterizerStateDesc::Default())
    .SetBlendState(BlendStateDesc::Opaque())
    .SetDepthStencilState(DepthStencilStateDesc::Default());

// é€šè¿‡ç®¡ç†å™¨åˆ›å»ºï¼ˆæ”¯æŒç¼“å­˜ï¼‰
auto& pipelineManager = IPipelineStateManager::Get();
Ref<IGraphicsPipeline> pipeline = pipelineManager.GetOrCreatePipeline(pipelineDesc);

// ç»‘å®š Pipelineï¼ˆæ¸²æŸ“çŠ¶æ€ï¼‰
pipeline->Bind();

// ç‹¬ç«‹ç»‘å®š VertexArrayï¼ˆé¡¶ç‚¹å¸ƒå±€ï¼‰
mesh->GetVertexArray()->Bind();
```

### é«˜çº§ä½¿ç”¨
```cpp
// é€æ˜ç‰©ä½“ç®¡çº¿ï¼ˆåªå…³æ³¨æ¸²æŸ“çŠ¶æ€ï¼‰
auto transparentPipeline = pipelineManager.GetOrCreatePipeline(
    GraphicsPipelineDesc{}
        .SetShader(transparentShader)
        .SetBlendState(BlendStateDesc::AlphaBlend())
        .SetDepthStencilState(DepthStencilStateDesc::ReadOnly())
);

// çº¿æ¡†æ¨¡å¼ç®¡çº¿
auto wireframePipeline = pipelineManager.GetOrCreatePipeline(
    GraphicsPipelineDesc{}
        .SetShader(wireframeShader)
        .SetRasterizerState(RasterizerStateDesc::Wireframe())
        .SetBlendState(BlendStateDesc::Opaque())
);

// VertexLayout åœ¨æ¸²æŸ“æ—¶ç‹¬ç«‹ç»‘å®š
// è¿™æ ·åŒä¸€ä¸ªPipelineå¯ä»¥ç”¨äºä¸åŒçš„é¡¶ç‚¹å¸ƒå±€
```

## å®ç°æ­¥éª¤å’Œä¼˜å…ˆçº§

### ğŸš€ ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¡†æ¶
1. åˆ›å»º `PipelineTypes.h` - å®šä¹‰æ‰€æœ‰åŸºç¡€ç±»å‹å’Œæšä¸¾
2. åˆ›å»º `IGraphicsPipeline.h` - å›¾å½¢ç®¡çº¿æ¥å£
3. åˆ›å»º `IPipelineStateManager.h` - ç®¡çº¿çŠ¶æ€ç®¡ç†å™¨æ¥å£

### ğŸ¯ ç¬¬äºŒé˜¶æ®µï¼šD3D12å®ç°
4. å®ç° `D3D12GraphicsPipeline` - æ ¸å¿ƒD3D12ç®¡çº¿å®ç°
5. å®ç° `D3D12PipelineStateManager` - D3D12ç®¡çº¿ç®¡ç†
6. é›†æˆåˆ°ç°æœ‰æ¸²æŸ“ç³»ç»Ÿ

### ğŸ”§ ç¬¬ä¸‰é˜¶æ®µï¼šç³»ç»Ÿé›†æˆ
7. é‡æ„ `SceneViewLayer.cpp` ä½¿ç”¨æ–°çš„ç®¡çº¿ç³»ç»Ÿ
8. æ·»åŠ ç®¡çº¿ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–
9. å®Œå–„é”™è¯¯å¤„ç†å’Œè°ƒè¯•ä¿¡æ¯

### ğŸŒŸ ç¬¬å››é˜¶æ®µï¼šOpenGLæ”¯æŒ (æœªæ¥)
10. å®ç° `OpenGLGraphicsPipeline` - OpenGLç®¡çº¿å®ç°
11. å®ç° `OpenGLPipelineStateManager` - OpenGLç®¡çº¿ç®¡ç†
12. è·¨å¹³å°æµ‹è¯•å’Œä¼˜åŒ–

## Unity SRP Batch å¼æ¶æ„è®¾è®¡

### ğŸ¯ **æ­£ç¡®çš„åˆ†å±‚è®¾è®¡**

åŸºäºUnity SRP Batchçš„è®¾è®¡ç†å¿µï¼Œæˆ‘ä»¬çš„ç³»ç»Ÿåº”è¯¥é‡‡ç”¨ä»¥ä¸‹åˆ†å±‚ï¼š

```
ğŸ“Š åº”ç”¨å±‚ (SceneRenderer/CameraRenderer)
â”œâ”€â”€ ğŸ”„ æ‰¹å¤„ç†é€»è¾‘ (ç±»ä¼¼Unity SRP Batcher)
â”‚   â”œâ”€â”€ æŒ‰Shaderåˆ†ç»„ç‰©ä½“
â”‚   â”œâ”€â”€ GPU Instancingå†³ç­–
â”‚   â””â”€â”€ ç»˜åˆ¶å‘½ä»¤æ’åºä¼˜åŒ–
â”œâ”€â”€ ğŸ“‹ ç»˜åˆ¶å‘½ä»¤æ”¶é›† (ç±»ä¼¼Unity CommandBuffer)
â”‚   â”œâ”€â”€ è§†é”¥å‰”é™¤
â”‚   â”œâ”€â”€ LODé€‰æ‹©
â”‚   â””â”€â”€ é€æ˜åº¦æ’åº
â””â”€â”€ ğŸ¯ æ¸²æŸ“é˜Ÿåˆ—ç®¡ç†

ğŸ“¦ æè´¨ç³»ç»Ÿå±‚
â”œâ”€â”€ ğŸ¨ æè´¨å‚æ•°ç®¡ç† (ç±»ä¼¼Unity MaterialPropertyBlock)
â”œâ”€â”€ âš™ï¸ PipelineçŠ¶æ€æå– (ä»æè´¨ä¸­æå–æ¸²æŸ“çŠ¶æ€)
â””â”€â”€ ğŸ”— Shaderå˜ä½“ç®¡ç†

ğŸ”§ RHIå±‚ (GraphicsPipelineç³»ç»Ÿ)
â”œâ”€â”€ ğŸ­ PipelineçŠ¶æ€å¯¹è±¡ç®¡ç† (çº¯æ¸²æŸ“çŠ¶æ€)
â”œâ”€â”€ ğŸ“ VertexArrayç‹¬ç«‹ç®¡ç† (ä¸ä¾èµ–Pipeline)
â””â”€â”€ ğŸ® CommandListæ‰§è¡Œ
```

### ğŸš€ **å…³é”®åˆ†ç¦»åŸåˆ™**

1. **Pipeline != VertexLayout**
   ```cpp
   // âŒ é”™è¯¯ï¼šPipelineåŒ…å«VertexLayout
   auto pipeline = CreatePipeline(shader, vertexLayout, renderStates);
   
   // âœ… æ­£ç¡®ï¼šåˆ†ç¦»ç®¡ç†
   auto pipeline = CreatePipeline(shader, renderStates);  // åªæœ‰æ¸²æŸ“çŠ¶æ€
   auto vertexArray = mesh->GetVertexArray();           // ç‹¬ç«‹çš„é¡¶ç‚¹å¸ƒå±€
   
   // ç»‘å®šæ—¶åˆ†åˆ«è®¾ç½®
   pipeline->Bind();      // è®¾ç½®PSOå’Œæ ¹ç­¾å
   vertexArray->Bind();   // è®¾ç½®é¡¶ç‚¹ç¼“å†²åŒºå’Œè¾“å…¥å¸ƒå±€
   ```

2. **æ‰¹å¤„ç†åœ¨åº”ç”¨å±‚ï¼Œä¸åœ¨RHIå±‚**
   ```cpp
   // åº”ç”¨å±‚æ‰¹å¤„ç†é€»è¾‘
   class SRPBatcher {
   public:
       void CollectDrawCommands(const Scene& scene);
       void SortByShader();                    // æŒ‰Shaderåˆ†ç»„
       void GroupInstancedObjects();           // è¯†åˆ«å¯å®ä¾‹åŒ–çš„ç‰©ä½“
       void Execute(CommandList& cmdList);     // æ‰§è¡Œä¼˜åŒ–åçš„ç»˜åˆ¶
   };
   
   // RHIå±‚åªè´Ÿè´£çŠ¶æ€è®¾ç½®
   class GraphicsPipeline {
       void Bind();  // åªè®¾ç½®æ¸²æŸ“çŠ¶æ€ï¼Œä¸å‚ä¸æ‰¹å¤„ç†é€»è¾‘
   };
   ```

3. **æè´¨ç³»ç»Ÿæä¾›çŠ¶æ€ä¿¡æ¯**
   ```cpp
   class Material {
   public:
       // æè´¨æä¾›Pipelineåˆ›å»ºæ‰€éœ€çš„æ¸²æŸ“çŠ¶æ€
       RenderStateDesc GetRenderState() const;
       Ref<Shader> GetShader() const;
       
       // ä½†ä¸å‚ä¸æ‰¹å¤„ç†å†³ç­–
       void UploadParameters(ConstantBuffer& buffer);
   };
   ```

### ğŸ”„ **Unity SRP Batch æµç¨‹å¯¹æ¯”**

#### Unity SRP Batch æµç¨‹ï¼š
```
Culling â†’ Sorting â†’ Batching â†’ GPU Upload â†’ Draw Calls
    â†“         â†“         â†“           â†“           â†“
åº”ç”¨å±‚     åº”ç”¨å±‚     åº”ç”¨å±‚      æè´¨å±‚      RHIå±‚
```

#### æˆ‘ä»¬çš„å¯¹åº”æµç¨‹ï¼š
```cpp
// 1. åº”ç”¨å±‚ï¼šæ”¶é›†å’Œæ‰¹å¤„ç†
SRPBatcher batcher;
batcher.CollectDrawCommands(scene);
batcher.SortByShader();
batcher.GroupInstancedObjects();

// 2. æè´¨å±‚ï¼šçŠ¶æ€æå–å’Œå‚æ•°ç®¡ç†
for (auto& drawCmd : batcher.GetCommands()) {
    auto renderState = drawCmd.material->GetRenderState();
    auto pipeline = pipelineManager.GetOrCreatePipeline(renderState);
    drawCmd.pipeline = pipeline;
}

// 3. RHIå±‚ï¼šé«˜æ•ˆæ‰§è¡Œ
batcher.Execute(commandList);
```

### ğŸ® **å®é™…ç»˜åˆ¶æ—¶çš„åˆ†ç¦»**

```cpp
void SRPBatcher::Execute(CommandList& cmdList) {
    GraphicsPipeline* currentPipeline = nullptr;
    VertexArray* currentVertexArray = nullptr;
    
    for (auto& cmd : m_OptimizedCommands) {
        // 1. PipelineçŠ¶æ€åˆ‡æ¢ï¼ˆæ¸²æŸ“çŠ¶æ€ï¼‰
        if (currentPipeline != cmd.pipeline) {
            currentPipeline = cmd.pipeline;
            currentPipeline->Bind();  // è®¾ç½®PSO, æ ¹ç­¾å, æ¸²æŸ“çŠ¶æ€
        }
        
        // 2. VertexArrayåˆ‡æ¢ï¼ˆé¡¶ç‚¹å¸ƒå±€ï¼‰- ç‹¬ç«‹äºPipeline
        if (currentVertexArray != cmd.mesh->GetVertexArray()) {
            currentVertexArray = cmd.mesh->GetVertexArray();
            currentVertexArray->Bind();  // è®¾ç½®é¡¶ç‚¹ç¼“å†²åŒºå’Œè¾“å…¥å¸ƒå±€
        }
        
        // 3. æè´¨å‚æ•°ç»‘å®š
        cmd.material->BindParameters(cmdList);
        
        // 4. ç»˜åˆ¶è°ƒç”¨
        cmdList.DrawIndexed(cmd.indexCount, cmd.startIndex);
    }
}
```

## è®¾è®¡ä¼˜åŠ¿

### âœ… **ç¬¦åˆç°æœ‰RHIé£æ ¼**
- æ¥å£æŠ½è±¡ä¸å®ç°åˆ†ç¦»
- ç±»å‹å®šä¹‰ç‹¬ç«‹
- å•ä¾‹ç®¡ç†æ¨¡å¼
- å¥æŸ„è®¾è®¡æ¨¡å¼

### âœ… **è·¨å¹³å°å…¼å®¹æ€§**
- D3D12: é¢„ç¼–è¯‘PSOæ¨¡å¼ï¼Œé«˜æ€§èƒ½
- OpenGL: è¿è¡Œæ—¶çŠ¶æ€è®¾ç½®æ¨¡å¼ï¼Œçµæ´»æ€§
- ç»Ÿä¸€çš„æŠ½è±¡æ¥å£

### âœ… **æ€§èƒ½ä¼˜åŒ–**
- ç®¡çº¿çŠ¶æ€ç¼“å­˜å’Œå¤ç”¨
- å“ˆå¸Œå¿«é€ŸæŸ¥æ‰¾
- å»¶è¿ŸçŠ¶æ€è®¾ç½®ï¼ˆOpenGLï¼‰

### âœ… **æ˜“ç”¨æ€§**
- é“¾å¼è®¾ç½®API
- ä¾¿æ·çš„é¢„è®¾çŠ¶æ€
- æ¸…æ™°çš„é”™è¯¯å¤„ç†

## æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼šç®¡çº¿çŠ¶æ€å¯¹è±¡åˆ›å»ºå¼€é”€å¤§ï¼Œå¿…é¡»å®ç°ç¼“å­˜æœºåˆ¶
2. **å†…å­˜ç®¡ç†**ï¼šç¡®ä¿æ‰€æœ‰ComPtrå’Œèµ„æºæ­£ç¡®é‡Šæ”¾
3. **é”™è¯¯å¤„ç†**ï¼šæ·»åŠ å®Œå–„çš„éªŒè¯å’Œé”™è¯¯æŠ¥å‘Š
4. **çº¿ç¨‹å®‰å…¨**ï¼šè€ƒè™‘å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„ç®¡çº¿åˆ›å»ºå’Œç¼“å­˜
5. **è°ƒè¯•æ”¯æŒ**ï¼šæ·»åŠ è°ƒè¯•ä¿¡æ¯å’Œæ€§èƒ½ç»Ÿè®¡ 